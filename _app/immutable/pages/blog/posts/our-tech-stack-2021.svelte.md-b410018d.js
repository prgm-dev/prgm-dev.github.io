import{S as pr,i as hr,s as ur,D as qt,x as cr,y as dr,z as mr,A as vr,B as nr,r as yr,p as wr,C as _r,X as ir,e as s,t as o,k as c,c as n,a as i,h as a,d as t,m as d,b as h,g as f,H as r,n as kr}from"../../../chunks/index-e323637a.js";import{B as Sr}from"../../../chunks/BlogLayout-3f2c89bf.js";import"../../../chunks/routes-991dd4a7.js";import"../../../chunks/stores-e73f7c49.js";function gr(J){let p,m,_,N,u,v,$,Y,Qe,Be,ee,We,Je,he,D,$e,ue,y,te,De,Fe,re,He,Ke,F,Me,ce,S,Ve,H,oe,de,g,ze,I,Ce,je,me,L,q,Ue,Xe,ve,b,Ze,ae,Ye,et,ye,E,tt,le,rt,ot,we,k,O,at,lt,se,st,nt,_e,K,it,ke,A,ft,M,ne,Se,T,pt,V,ht,ut,ge,P,ct,Q,dt,mt,be,w,vt,B,yt,wt,W,_t,kt,Ee,x,St,ie,gt,bt,Ae,z,Et,Te,G,At,C,fe,Pe,j,Tt,xe,R,Pt,U,xt,Gt;return{c(){p=s("p"),m=s("strong"),_=o("TL;DR:"),N=o(" This year, we are trying "),u=s("strong"),v=o("Apollo GraphQL"),$=o(" on the Backend, and "),Y=s("strong"),Qe=o("Svelte Kit"),Be=o(` on the Frontend,
both with `),ee=s("strong"),We=o("Typescript"),Je=o("."),he=c(),D=s("p"),$e=o("Want to know how it\u2019s working out for us? Read on!"),ue=c(),y=s("p"),te=s("strong"),De=o("Note:"),Fe=o(" If you\u2019re more into REST APIs, our tech stack last year achieved that very efficiently with Python\u2019s "),re=s("strong"),He=o("FastAPI"),Ke=o(`.
See our `),F=s("a"),Me=o("article here"),ce=c(),S=s("h2"),Ve=o("Backend: GraphQL + Apollo Server"),H=s("a"),oe=s("span"),de=c(),g=s("p"),ze=o(`In our quest to find a faster way to build Backend APIs, we came across
`),I=s("a"),Ce=o("Apollo GraphQL"),je=o("."),me=c(),L=s("p"),q=s("a"),Ue=o("GraphQL"),Xe=o(` is great because it allows you to build your APIs in a schema-first manner.
This allows you to describe all of your data models (and their relationships) in one place,
which is great for backend and frontend developers alike as it provides a clear and concise reference
of all the data your API will expose.`),ve=c(),b=s("p"),Ze=o("Additionally, GraphQL allows you to "),ae=s("strong"),Ye=o("organize your data in a way that makes sense to you"),et=o(`,
rather than trying to shoe-horn it into your database.`),ye=c(),E=s("p"),tt=o("GraphQL also "),le=s("strong"),rt=o("works very well with the type system of Typescript"),ot=o(`, improving developer
experience with tools like auto-completion, auto-documentation, and type-checkers,
helping to catch bugs and design errors early.`),we=c(),k=s("p"),O=s("a"),at=o("Apollo Server"),lt=o(`
is great too, because it provides a developer-efficient way of implementing resolvers.
Resolvers are the actual functions that take in a GraphQL query and return the appropriate data.
Apollo allows you to organize your resolvers in a modular way. It then figures out relationships
in your schema, `),se=s("strong"),st=o("implements the boring boilerplate resolvers for you"),nt=o(` and lets you implement the few complex
one, all while making it super easy to test them.`),_e=c(),K=s("p"),it=o(`Similarly to a REST API backend, the bulk of your GraphQL implementation will be in your resolvers,
which makes Apollo Server feel like a breath of fresh air.`),ke=c(),A=s("h2"),ft=o("Frontend: SvelteKit"),M=s("a"),ne=s("span"),Se=c(),T=s("p"),pt=o("Nuxt.JS from "),V=s("a"),ht=o("our stack last year"),ut=o(" was great, but we wanted something faster to iterate."),ge=c(),P=s("p"),ct=o("We are eagerly "),Q=s("a"),dt=o("waiting for Nuxt 3 to come out"),mt=o(`,
as it would leverage the many improvements of Vue 3, like the improved
support for Typescript. Unfortunately, at the time of writing (July 2021), it\u2019s not even in Beta yet.`),be=c(),w=s("p"),vt=o("After researching and trying different alternatives, we found "),B=s("a"),yt=o("SvelteKit"),wt=o(`,
which is a framework around `),W=s("a"),_t=o("Svelte"),kt=o("."),Ee=c(),x=s("p"),St=o(`The promise of Svelte is to provide the developer with an experience to the likes of reactive frameworks like
Vue and React, but instead of relying on a virtual DOM like its counterpart, `),ie=s("strong"),gt=o(`Svelte applies diffing algorithms
directly on the Browser\u2019s DOM`),bt=o(", using vanilla JS and human-readable HTML and CSS."),Ae=c(),z=s("p"),Et=o(`While the speed improvements are noticeable sometimes and appreciable, they were not our main
concern as Nuxt, and more particularly Vue was already quite efficient. But Svelte conquered us
through its very elegant design, requiring code that more closely resembles native JS,
which means less documentation to read, less edge cases, and simpler developer onboarding.`),Te=c(),G=s("h2"),At=o("What\u2019s next"),C=s("a"),fe=s("span"),Pe=c(),j=s("p"),Tt=o(`We\u2019re lucky to have many projects to try many different technologies, and
so far this year, this is what we have decided to go with. We\u2019ll keep this article updated
as we get more familiar with the technologies.`),xe=c(),R=s("p"),Pt=o("In the meantime, you can find out more about our "),U=s("a"),xt=o("2020 Tech Stack"),Gt=o(`, which focuses on REST APIs
and uses Nuxt.JS on the frontend.`),this.h()},l(e){p=n(e,"P",{});var l=i(p);m=n(l,"STRONG",{});var Ot=i(m);_=a(Ot,"TL;DR:"),Ot.forEach(t),N=a(l," This year, we are trying "),u=n(l,"STRONG",{});var Qt=i(u);v=a(Qt,"Apollo GraphQL"),Qt.forEach(t),$=a(l," on the Backend, and "),Y=n(l,"STRONG",{});var Bt=i(Y);Qe=a(Bt,"Svelte Kit"),Bt.forEach(t),Be=a(l,` on the Frontend,
both with `),ee=n(l,"STRONG",{});var Wt=i(ee);We=a(Wt,"Typescript"),Wt.forEach(t),Je=a(l,"."),l.forEach(t),he=d(e),D=n(e,"P",{});var Jt=i(D);$e=a(Jt,"Want to know how it\u2019s working out for us? Read on!"),Jt.forEach(t),ue=d(e),y=n(e,"P",{});var X=i(y);te=n(X,"STRONG",{});var $t=i(te);De=a($t,"Note:"),$t.forEach(t),Fe=a(X," If you\u2019re more into REST APIs, our tech stack last year achieved that very efficiently with Python\u2019s "),re=n(X,"STRONG",{});var Dt=i(re);He=a(Dt,"FastAPI"),Dt.forEach(t),Ke=a(X,`.
See our `),F=n(X,"A",{href:!0});var Ft=i(F);Me=a(Ft,"article here"),Ft.forEach(t),X.forEach(t),ce=d(e),S=n(e,"H2",{id:!0});var Rt=i(S);Ve=a(Rt,"Backend: GraphQL + Apollo Server"),H=n(Rt,"A",{href:!0});var Ht=i(H);oe=n(Ht,"SPAN",{class:!0}),i(oe).forEach(t),Ht.forEach(t),Rt.forEach(t),de=d(e),g=n(e,"P",{});var Ge=i(g);ze=a(Ge,`In our quest to find a faster way to build Backend APIs, we came across
`),I=n(Ge,"A",{href:!0,rel:!0});var Kt=i(I);Ce=a(Kt,"Apollo GraphQL"),Kt.forEach(t),je=a(Ge,"."),Ge.forEach(t),me=d(e),L=n(e,"P",{});var Nt=i(L);q=n(Nt,"A",{href:!0,rel:!0});var Mt=i(q);Ue=a(Mt,"GraphQL"),Mt.forEach(t),Xe=a(Nt,` is great because it allows you to build your APIs in a schema-first manner.
This allows you to describe all of your data models (and their relationships) in one place,
which is great for backend and frontend developers alike as it provides a clear and concise reference
of all the data your API will expose.`),Nt.forEach(t),ve=d(e),b=n(e,"P",{});var Re=i(b);Ze=a(Re,"Additionally, GraphQL allows you to "),ae=n(Re,"STRONG",{});var Vt=i(ae);Ye=a(Vt,"organize your data in a way that makes sense to you"),Vt.forEach(t),et=a(Re,`,
rather than trying to shoe-horn it into your database.`),Re.forEach(t),ye=d(e),E=n(e,"P",{});var Ne=i(E);tt=a(Ne,"GraphQL also "),le=n(Ne,"STRONG",{});var zt=i(le);rt=a(zt,"works very well with the type system of Typescript"),zt.forEach(t),ot=a(Ne,`, improving developer
experience with tools like auto-completion, auto-documentation, and type-checkers,
helping to catch bugs and design errors early.`),Ne.forEach(t),we=d(e),k=n(e,"P",{});var pe=i(k);O=n(pe,"A",{href:!0,rel:!0});var Ct=i(O);at=a(Ct,"Apollo Server"),Ct.forEach(t),lt=a(pe,`
is great too, because it provides a developer-efficient way of implementing resolvers.
Resolvers are the actual functions that take in a GraphQL query and return the appropriate data.
Apollo allows you to organize your resolvers in a modular way. It then figures out relationships
in your schema, `),se=n(pe,"STRONG",{});var jt=i(se);st=a(jt,"implements the boring boilerplate resolvers for you"),jt.forEach(t),nt=a(pe,` and lets you implement the few complex
one, all while making it super easy to test them.`),pe.forEach(t),_e=d(e),K=n(e,"P",{});var Ut=i(K);it=a(Ut,`Similarly to a REST API backend, the bulk of your GraphQL implementation will be in your resolvers,
which makes Apollo Server feel like a breath of fresh air.`),Ut.forEach(t),ke=d(e),A=n(e,"H2",{id:!0});var It=i(A);ft=a(It,"Frontend: SvelteKit"),M=n(It,"A",{href:!0});var Xt=i(M);ne=n(Xt,"SPAN",{class:!0}),i(ne).forEach(t),Xt.forEach(t),It.forEach(t),Se=d(e),T=n(e,"P",{});var Ie=i(T);pt=a(Ie,"Nuxt.JS from "),V=n(Ie,"A",{href:!0});var Zt=i(V);ht=a(Zt,"our stack last year"),Zt.forEach(t),ut=a(Ie," was great, but we wanted something faster to iterate."),Ie.forEach(t),ge=d(e),P=n(e,"P",{});var Le=i(P);ct=a(Le,"We are eagerly "),Q=n(Le,"A",{href:!0,rel:!0});var Yt=i(Q);dt=a(Yt,"waiting for Nuxt 3 to come out"),Yt.forEach(t),mt=a(Le,`,
as it would leverage the many improvements of Vue 3, like the improved
support for Typescript. Unfortunately, at the time of writing (July 2021), it\u2019s not even in Beta yet.`),Le.forEach(t),be=d(e),w=n(e,"P",{});var Z=i(w);vt=a(Z,"After researching and trying different alternatives, we found "),B=n(Z,"A",{href:!0,rel:!0});var er=i(B);yt=a(er,"SvelteKit"),er.forEach(t),wt=a(Z,`,
which is a framework around `),W=n(Z,"A",{href:!0,rel:!0});var tr=i(W);_t=a(tr,"Svelte"),tr.forEach(t),kt=a(Z,"."),Z.forEach(t),Ee=d(e),x=n(e,"P",{});var qe=i(x);St=a(qe,`The promise of Svelte is to provide the developer with an experience to the likes of reactive frameworks like
Vue and React, but instead of relying on a virtual DOM like its counterpart, `),ie=n(qe,"STRONG",{});var rr=i(ie);gt=a(rr,`Svelte applies diffing algorithms
directly on the Browser\u2019s DOM`),rr.forEach(t),bt=a(qe,", using vanilla JS and human-readable HTML and CSS."),qe.forEach(t),Ae=d(e),z=n(e,"P",{});var or=i(z);Et=a(or,`While the speed improvements are noticeable sometimes and appreciable, they were not our main
concern as Nuxt, and more particularly Vue was already quite efficient. But Svelte conquered us
through its very elegant design, requiring code that more closely resembles native JS,
which means less documentation to read, less edge cases, and simpler developer onboarding.`),or.forEach(t),Te=d(e),G=n(e,"H2",{id:!0});var Lt=i(G);At=a(Lt,"What\u2019s next"),C=n(Lt,"A",{href:!0});var ar=i(C);fe=n(ar,"SPAN",{class:!0}),i(fe).forEach(t),ar.forEach(t),Lt.forEach(t),Pe=d(e),j=n(e,"P",{});var lr=i(j);Tt=a(lr,`We\u2019re lucky to have many projects to try many different technologies, and
so far this year, this is what we have decided to go with. We\u2019ll keep this article updated
as we get more familiar with the technologies.`),lr.forEach(t),xe=d(e),R=n(e,"P",{});var Oe=i(R);Pt=a(Oe,"In the meantime, you can find out more about our "),U=n(Oe,"A",{href:!0});var sr=i(U);xt=a(sr,"2020 Tech Stack"),sr.forEach(t),Gt=a(Oe,`, which focuses on REST APIs
and uses Nuxt.JS on the frontend.`),Oe.forEach(t),this.h()},h(){h(F,"href","./our-tech-stack-2020"),h(oe,"class","anchor-sign"),h(H,"href","#backend-graphql--apollo-server"),h(S,"id","backend-graphql--apollo-server"),h(I,"href","https://www.apollographql.com"),h(I,"rel","nofollow"),h(q,"href","https://graphql.org"),h(q,"rel","nofollow"),h(O,"href","https://www.apollographql.com/docs/apollo-server/"),h(O,"rel","nofollow"),h(ne,"class","anchor-sign"),h(M,"href","#frontend-sveltekit"),h(A,"id","frontend-sveltekit"),h(V,"href","./our-tech-stack-2020"),h(Q,"href","https://unofficial-nuxt3-countdown.netlify.app"),h(Q,"rel","nofollow"),h(B,"href","https://kit.svelte.dev"),h(B,"rel","nofollow"),h(W,"href","https://svelte.dev"),h(W,"rel","nofollow"),h(fe,"class","anchor-sign"),h(C,"href","#whats-next"),h(G,"id","whats-next"),h(U,"href","./our-tech-stack-2020")},m(e,l){f(e,p,l),r(p,m),r(m,_),r(p,N),r(p,u),r(u,v),r(p,$),r(p,Y),r(Y,Qe),r(p,Be),r(p,ee),r(ee,We),r(p,Je),f(e,he,l),f(e,D,l),r(D,$e),f(e,ue,l),f(e,y,l),r(y,te),r(te,De),r(y,Fe),r(y,re),r(re,He),r(y,Ke),r(y,F),r(F,Me),f(e,ce,l),f(e,S,l),r(S,Ve),r(S,H),r(H,oe),f(e,de,l),f(e,g,l),r(g,ze),r(g,I),r(I,Ce),r(g,je),f(e,me,l),f(e,L,l),r(L,q),r(q,Ue),r(L,Xe),f(e,ve,l),f(e,b,l),r(b,Ze),r(b,ae),r(ae,Ye),r(b,et),f(e,ye,l),f(e,E,l),r(E,tt),r(E,le),r(le,rt),r(E,ot),f(e,we,l),f(e,k,l),r(k,O),r(O,at),r(k,lt),r(k,se),r(se,st),r(k,nt),f(e,_e,l),f(e,K,l),r(K,it),f(e,ke,l),f(e,A,l),r(A,ft),r(A,M),r(M,ne),f(e,Se,l),f(e,T,l),r(T,pt),r(T,V),r(V,ht),r(T,ut),f(e,ge,l),f(e,P,l),r(P,ct),r(P,Q),r(Q,dt),r(P,mt),f(e,be,l),f(e,w,l),r(w,vt),r(w,B),r(B,yt),r(w,wt),r(w,W),r(W,_t),r(w,kt),f(e,Ee,l),f(e,x,l),r(x,St),r(x,ie),r(ie,gt),r(x,bt),f(e,Ae,l),f(e,z,l),r(z,Et),f(e,Te,l),f(e,G,l),r(G,At),r(G,C),r(C,fe),f(e,Pe,l),f(e,j,l),r(j,Tt),f(e,xe,l),f(e,R,l),r(R,Pt),r(R,U),r(U,xt),r(R,Gt)},p:kr,d(e){e&&t(p),e&&t(he),e&&t(D),e&&t(ue),e&&t(y),e&&t(ce),e&&t(S),e&&t(de),e&&t(g),e&&t(me),e&&t(L),e&&t(ve),e&&t(b),e&&t(ye),e&&t(E),e&&t(we),e&&t(k),e&&t(_e),e&&t(K),e&&t(ke),e&&t(A),e&&t(Se),e&&t(T),e&&t(ge),e&&t(P),e&&t(be),e&&t(w),e&&t(Ee),e&&t(x),e&&t(Ae),e&&t(z),e&&t(Te),e&&t(G),e&&t(Pe),e&&t(j),e&&t(xe),e&&t(R)}}}function br(J){let p,m;const _=[J[0],fr];let N={$$slots:{default:[gr]},$$scope:{ctx:J}};for(let u=0;u<_.length;u+=1)N=qt(N,_[u]);return p=new Sr({props:N}),{c(){cr(p.$$.fragment)},l(u){dr(p.$$.fragment,u)},m(u,v){mr(p,u,v),m=!0},p(u,[v]){const $=v&1?vr(_,[v&1&&nr(u[0]),v&0&&nr(fr)]):{};v&2&&($.$$scope={dirty:v,ctx:u}),p.$set($)},i(u){m||(yr(p.$$.fragment,u),m=!0)},o(u){wr(p.$$.fragment,u),m=!1},d(u){_r(p,u)}}}const fr={title:"Our tech stack for 2021",dateCreated:"2021-07-06T00:00:00.000Z",description:"Through our experience building many projects in the span of a few months, we\u2019ve completely revamped our 2020 stack to improve our efficiency at testing new ideas faster than before."};function Er(J,p,m){return J.$$set=_=>{m(0,p=qt(qt({},p),ir(_)))},p=ir(p),[p]}class Gr extends pr{constructor(p){super(),hr(this,p,Er,br,ur,{})}}export{Gr as default,fr as metadata};
